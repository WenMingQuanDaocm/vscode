// 时间复杂度T(n) = O(f(n))
// for(int i = 1;i <= n;i++)//循环了n次，当i=n还要再判断一次，
// //则执行了n+1次，频度为n+1
// {
//     for(int j = 1;j <= n;j++)//n*(n+1)
//     {
//         ......;//n*n
//         for(int k = 1;k <= n;k++)//n*n*(n+1)
//         {
//             ......;//n*n*n
//         }
//     }
// }

// f(n)=n+1+n*(n+1)+n*n+n*n*(n+1)+n*n*n=2*n^3+3*n^2+2*n+1
// 计算时间复杂度时忽略所有低次幂和最高次幂的系数
// 则T(n)=O(f(n))=O(n^3)

// 当n=0时，只执行一次（最好情况）
//  最好时间复杂度：算法在最好情况下的时间复杂度
//  最坏~        ：     最坏
//  平均~        ：算法在所有情况下，按照输入实际以等概率出现时
//  算法计量的加权平均值
// 对算法复杂度的度量，通常只讨论算法在最坏情况下的时间复杂度
// 即分析在最坏情况下算法执行时间的上界

// 常量阶
// x++;
// s = 0;
// f(n)=1+1=2,T(n)=O(1)

// for(i=1;i<=100;i++)
// {

// }
// 该for循环不随n的增大而增大，还是O(1)

// 例
// int sum = 0;
// for(int i=1;i<n;i*=2)
// {
//     for(int j=0;j<i;j++)
//     {
//         sum++;
//     }
// }

// 外层次数   1   2   3   4   t 
// i        2^0 2^1 2^2 2^3 2^(t-1)
// 内层次数  2^0 2^1 2^2 2^3 2^(t-1)